;;;;;;;;;;;;;;;;;;;;;;;;; constraints that produced an invalid model ;;;;;;;;;;;;;;;;;;;;
; See debug0_model.smt for the model

(declare-sort Epoch 0)
(declare-sort Node 0)
(declare-fun le (Epoch Epoch) Bool)
(declare-fun init.ep (Node) Epoch)
(declare-fun init.held (Node) Bool)
(declare-fun init.transfer (Epoch Node) Bool)
(declare-fun init.locked (Epoch Node) Bool)
(declare-fun one () Epoch)
(declare-fun first () Node)
(declare-fun zero () Epoch)
(declare-fun post.ep (Node) Epoch)
(declare-fun post.held (Node) Bool)
(declare-fun post.transfer (Epoch Node) Bool)
(declare-fun post.locked (Epoch Node) Bool)
(declare-fun pre.ep (Node) Epoch)
(declare-fun pre.held (Node) Bool)
(declare-fun pre.transfer (Epoch Node) Bool)
(declare-fun pre.locked (Epoch Node) Bool)
(assert (let ((a!1 (forall ((e1 Epoch) (e2 Epoch) (e3 Epoch))
             (and (le e1 e1)
                  (=> (and (le e1 e2) (le e2 e3)) (le e1 e3))
                  (=> (and (le e1 e2) (le e2 e1)) (= e1 e2))
                  (or (le e1 e2) (le e2 e1))
                  (le zero e1)
                  (distinct one zero))))
      (a!2 (forall ((n Node) (e Epoch))
             (and (= (init.held n) (= n first))
                  (=> (distinct n first) (= (init.ep n) zero))
                  (= (init.ep first) one)
                  (= (init.transfer e n) false)
                  (= (init.locked e n) false))))
      (a!3 (forall ((N Node) (M Node) (N1 Node) (N2 Node) (E1 Epoch) (E2 Epoch))
             (let ((a!1 (and (init.transfer E1 N1)
                             (not (le E1 (init.ep N1)))
                             (init.transfer E2 N2)
                             (not (le E2 (init.ep N2)))))
                   (a!2 (and (init.transfer E1 N1) (not (le E1 (init.ep N1))))))
               (and (=> (and (init.held N) (init.held M)) (= N M))
                    (=> a!1 (and (= E1 E2) (= N1 N2)))
                    (=> a!2 (not (init.held N2)))))))
      (a!4 (forall ((N Node) (N1 Node) (E Epoch) (E1 Epoch))
             (let ((a!1 (and (init.transfer E N)
                             (not (le E (init.ep N)))
                             (init.transfer E1 N1)
                             (or (not (= N N1)) (not (= E E1))))))
               (and (=> a!1 (not (le E E1)))
                    (=> (and (init.held N) (init.transfer E1 N1))
                        (le E1 (init.ep N)))))))
      (a!5 (forall ((N Node) (N1 Node) (E Epoch))
             (let ((a!1 (and (init.transfer E N) (not (le E (init.ep N))))))
             (let ((a!2 (=> a!1 (not (le E (init.ep N1))))))
               (and a!2 (=> (init.held N) (le (init.ep N1) (init.ep N)))))))))
  (and a!1
       a!2
       (forall ((N Node) (E Epoch)) (=> (init.locked E N) (init.transfer E N)))
       a!3
       a!4
       a!5)))
(assert (let ((a!1 (forall ((e1 Epoch) (e2 Epoch) (e3 Epoch))
             (and (le e1 e1)
                  (=> (and (le e1 e2) (le e2 e3)) (le e1 e3))
                  (=> (and (le e1 e2) (le e2 e1)) (= e1 e2))
                  (or (le e1 e2) (le e2 e1))
                  (le zero e1)
                  (distinct one zero))))
      (a!2 (forall ((N Node) (M Node) (N1 Node) (N2 Node) (E1 Epoch) (E2 Epoch))
             (let ((a!1 (and (pre.transfer E1 N1)
                             (not (le E1 (pre.ep N1)))
                             (pre.transfer E2 N2)
                             (not (le E2 (pre.ep N2)))))
                   (a!2 (and (pre.transfer E1 N1) (not (le E1 (pre.ep N1))))))
               (and (=> (and (pre.held N) (pre.held M)) (= N M))
                    (=> a!1 (and (= E1 E2) (= N1 N2)))
                    (=> a!2 (not (pre.held N2)))))))
      (a!3 (forall ((N Node) (N1 Node) (E Epoch) (E1 Epoch))
             (let ((a!1 (and (pre.transfer E N)
                             (not (le E (pre.ep N)))
                             (pre.transfer E1 N1)
                             (or (not (= N N1)) (not (= E E1))))))
               (and (=> a!1 (not (le E E1)))
                    (=> (and (pre.held N) (pre.transfer E1 N1))
                        (le E1 (pre.ep N)))))))
      (a!4 (forall ((N Node) (N1 Node) (E Epoch))
             (let ((a!1 (and (pre.transfer E N) (not (le E (pre.ep N))))))
             (let ((a!2 (=> a!1 (not (le E (pre.ep N1))))))
               (and a!2 (=> (pre.held N) (le (pre.ep N1) (pre.ep N))))))))
      (a!5 (forall ((n1 Node) (n2 Node) (e Epoch))
             (let ((a!1 (and (pre.held n1) (not (le e (pre.ep n1))))))
               (=> a!1 (and (post.transfer e n2) (= (post.held n1) false))))))
      (a!6 (forall ((N Node) (M Node) (N1 Node) (N2 Node) (E1 Epoch) (E2 Epoch))
             (let ((a!1 (and (post.transfer E1 N1)
                             (not (le E1 (post.ep N1)))
                             (post.transfer E2 N2)
                             (not (le E2 (post.ep N2)))))
                   (a!2 (and (post.transfer E1 N1) (not (le E1 (post.ep N1))))))
               (and (=> (and (post.held N) (post.held M)) (= N M))
                    (=> a!1 (and (= E1 E2) (= N1 N2)))
                    (=> a!2 (not (post.held N2)))))))
      (a!7 (forall ((N Node) (N1 Node) (E Epoch) (E1 Epoch))
             (let ((a!1 (and (post.transfer E N)
                             (not (le E (post.ep N)))
                             (post.transfer E1 N1)
                             (or (not (= N N1)) (not (= E E1))))))
               (and (=> a!1 (not (le E E1)))
                    (=> (and (post.held N) (post.transfer E1 N1))
                        (le E1 (post.ep N)))))))
      (a!8 (forall ((N Node) (N1 Node) (E Epoch))
             (let ((a!1 (and (post.transfer E N) (not (le E (post.ep N))))))
             (let ((a!2 (=> a!1 (not (le E (post.ep N1))))))
               (and a!2 (=> (post.held N) (le (post.ep N1) (post.ep N)))))))))
(let ((a!9 (and (forall ((N Node) (E Epoch))
                  (=> (post.locked E N) (post.transfer E N)))
                a!6
                a!7
                a!8)))
  (and a!1
       (forall ((N Node) (E Epoch)) (=> (pre.locked E N) (pre.transfer E N)))
       a!2
       a!3
       a!4
       a!5
       (not a!9)))))
(assert (let ((a!1 (forall ((e1 Epoch) (e2 Epoch) (e3 Epoch))
             (and (le e1 e1)
                  (=> (and (le e1 e2) (le e2 e3)) (le e1 e3))
                  (=> (and (le e1 e2) (le e2 e1)) (= e1 e2))
                  (or (le e1 e2) (le e2 e1))
                  (le zero e1)
                  (distinct one zero))))
      (a!2 (forall ((N Node) (M Node) (N1 Node) (N2 Node) (E1 Epoch) (E2 Epoch))
             (let ((a!1 (and (pre.transfer E1 N1)
                             (not (le E1 (pre.ep N1)))
                             (pre.transfer E2 N2)
                             (not (le E2 (pre.ep N2)))))
                   (a!2 (and (pre.transfer E1 N1) (not (le E1 (pre.ep N1))))))
               (and (=> (and (pre.held N) (pre.held M)) (= N M))
                    (=> a!1 (and (= E1 E2) (= N1 N2)))
                    (=> a!2 (not (pre.held N2)))))))
      (a!3 (forall ((N Node) (N1 Node) (E Epoch) (E1 Epoch))
             (let ((a!1 (and (pre.transfer E N)
                             (not (le E (pre.ep N)))
                             (pre.transfer E1 N1)
                             (or (not (= N N1)) (not (= E E1))))))
               (and (=> a!1 (not (le E E1)))
                    (=> (and (pre.held N) (pre.transfer E1 N1))
                        (le E1 (pre.ep N)))))))
      (a!4 (forall ((N Node) (N1 Node) (E Epoch))
             (let ((a!1 (and (pre.transfer E N) (not (le E (pre.ep N))))))
             (let ((a!2 (=> a!1 (not (le E (pre.ep N1))))))
               (and a!2 (=> (pre.held N) (le (pre.ep N1) (pre.ep N))))))))
      (a!5 (forall ((n Node) (e Epoch))
             (let ((a!1 (and (pre.transfer e n) (not (le e (pre.ep n))))))
               (=> a!1 (and (post.held n) (= (post.ep n) e) (post.locked e n))))))
      (a!6 (forall ((N Node) (M Node) (N1 Node) (N2 Node) (E1 Epoch) (E2 Epoch))
             (let ((a!1 (and (post.transfer E1 N1)
                             (not (le E1 (post.ep N1)))
                             (post.transfer E2 N2)
                             (not (le E2 (post.ep N2)))))
                   (a!2 (and (post.transfer E1 N1) (not (le E1 (post.ep N1))))))
               (and (=> (and (post.held N) (post.held M)) (= N M))
                    (=> a!1 (and (= E1 E2) (= N1 N2)))
                    (=> a!2 (not (post.held N2)))))))
      (a!7 (forall ((N Node) (N1 Node) (E Epoch) (E1 Epoch))
             (let ((a!1 (and (post.transfer E N)
                             (not (le E (post.ep N)))
                             (post.transfer E1 N1)
                             (or (not (= N N1)) (not (= E E1))))))
               (and (=> a!1 (not (le E E1)))
                    (=> (and (post.held N) (post.transfer E1 N1))
                        (le E1 (post.ep N)))))))
      (a!8 (forall ((N Node) (N1 Node) (E Epoch))
             (let ((a!1 (and (post.transfer E N) (not (le E (post.ep N))))))
             (let ((a!2 (=> a!1 (not (le E (post.ep N1))))))
               (and a!2 (=> (post.held N) (le (post.ep N1) (post.ep N)))))))))
(let ((a!9 (and (forall ((N Node) (E Epoch))
                  (=> (post.locked E N) (post.transfer E N)))
                a!6
                a!7
                a!8)))
  (and a!1
       (forall ((N Node) (E Epoch)) (=> (pre.locked E N) (pre.transfer E N)))
       a!2
       a!3
       a!4
       a!5
       (not a!9)))))