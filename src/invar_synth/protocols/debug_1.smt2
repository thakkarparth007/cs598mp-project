(declare-sort Node 0)
(declare-sort Epoch 0)
(declare-sort StateId 0)
(declare-sort ModelId 0)
(declare-fun locked (ModelId StateId Epoch Node) Bool)
(declare-fun init () StateId)
(declare-fun Model_M1 () ModelId)
(declare-fun transfer (ModelId StateId Epoch Node) Bool)
(declare-fun one (ModelId) Epoch)
(declare-fun ep (ModelId StateId Node) Epoch)
(declare-fun first (ModelId) Node)
(declare-fun zero (ModelId) Epoch)
(declare-fun held (ModelId StateId Node) Bool)
(declare-fun le (ModelId Epoch Epoch) Bool)
(declare-fun S () StateId)
(assert (forall ((Node_1 Node))
  (forall ((Epoch_1 Epoch))
    (and (= (held Model_M1 init Node_1) (= Node_1 (first Model_M1)))
         (=> (distinct Node_1 (first Model_M1))
             (= (ep Model_M1 init Node_1) (zero Model_M1)))
         (= (ep Model_M1 init (first Model_M1)) (one Model_M1))
         (= (transfer Model_M1 init Epoch_1 Node_1) false)
         (= (locked Model_M1 init Epoch_1 Node_1) false)))))
(assert (forall ((Epoch_1 Epoch))
  (forall ((Epoch_2 Epoch))
    (forall ((Epoch_3 Epoch))
      (and (le Model_M1 Epoch_1 Epoch_1)
           (=> (and (le Model_M1 Epoch_1 Epoch_2) (le Model_M1 Epoch_2 Epoch_3))
               (le Model_M1 Epoch_1 Epoch_3))
           (=> (and (le Model_M1 Epoch_1 Epoch_2) (le Model_M1 Epoch_2 Epoch_1))
               (= Epoch_1 Epoch_2))
           (or (le Model_M1 Epoch_1 Epoch_2) (le Model_M1 Epoch_2 Epoch_1))
           (le Model_M1 (zero Model_M1) Epoch_1)
           (distinct (one Model_M1) (zero Model_M1)))))))
(assert (let ((a!1 (forall ((N Node) (M Node) (N1 Node) (N2 Node) (E1 Epoch) (E2 Epoch))
             (let ((a!1 (and (transfer Model_M1 S E1 N1)
                             (not (le Model_M1 E1 (ep Model_M1 S N1)))
                             (transfer Model_M1 S E2 N2)
                             (not (le Model_M1 E2 (ep Model_M1 S N2)))))
                   (a!2 (and (transfer Model_M1 S E1 N1)
                             (not (le Model_M1 E1 (ep Model_M1 S N1))))))
               (and (=> (and (held Model_M1 S N) (held Model_M1 S M)) (= N M))
                    (=> a!1 (and (= E1 E2) (= N1 N2)))
                    (=> a!2 (not (held Model_M1 S N2)))))))
      (a!2 (forall ((N Node) (N1 Node) (E Epoch) (E1 Epoch))
             (let ((a!1 (and (transfer Model_M1 S E N)
                             (not (le Model_M1 E (ep Model_M1 S N)))
                             (transfer Model_M1 S E1 N1)
                             (or (not (= N N1)) (not (= E E1))))))
               (and (=> a!1 (not (le Model_M1 E E1)))
                    (=> (and (held Model_M1 S N) (transfer Model_M1 S E1 N1))
                        (le Model_M1 E1 (ep Model_M1 S N)))))))
      (a!3 (forall ((N Node) (N1 Node) (E Epoch))
             (let ((a!1 (and (transfer Model_M1 S E N)
                             (not (le Model_M1 E (ep Model_M1 S N))))))
             (let ((a!2 (=> a!1 (not (le Model_M1 E (ep Model_M1 S N1))))))
               (and a!2
                    (=> (held Model_M1 S N)
                        (le Model_M1 (ep Model_M1 S N1) (ep Model_M1 S N)))))))))
  (and (forall ((N Node) (E Epoch))
         (=> (locked Model_M1 S E N) (transfer Model_M1 S E N)))
       a!1
       a!2
       a!3)))
(assert (let ((a!1 (forall ((Epoch_1 Epoch))
             (forall ((Node_1 Node))
               (forall ((Node_2 Node))
                 (=> (and (locked Model_M1 S Epoch_1 Node_1)
                          (locked Model_M1 S Epoch_1 Node_2))
                     (= Node_1 Node_2)))))))
  (not a!1)))


(check-sat)
(get-model)