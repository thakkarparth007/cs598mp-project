(set-logic ALL)

(declare-sort Node)
(declare-sort Epoch)

;; universe for Epoch:
;;   Epoch!val!3 Epoch!val!4 Epoch!val!2 Epoch!val!1 Epoch!val!0 
;; -----------
;; definitions for universe elements:
(declare-fun Epoch!val!3 () Epoch)
(declare-fun Epoch!val!4 () Epoch)
(declare-fun Epoch!val!2 () Epoch)
(declare-fun Epoch!val!1 () Epoch)
(declare-fun Epoch!val!0 () Epoch)
;; cardinality constraint: - not having here

;; -----------
;; universe for Node:
;;   Node!val!0 
;; -----------
;; definitions for universe elements:
(declare-fun Node!val!0 () Node)
;; cardinality constraint: - not having here

(declare-fun held (Node) Bool)
(declare-fun locked (Epoch Node) Bool)
(declare-fun transfer (Epoch Node) Bool)
(declare-fun ep (Node) Epoch)

(synth-fun inv ((x Node)) Bool
    
    ;; Declare the non-terminals that would be used in the grammar
    ((Start Bool) (Atom Bool))

    ;; Define the grammar for allowed implementations of max2
    (
        (Start Bool 
               (
                (and Atom Atom)
                (or Atom Atom)
                (=> Atom Atom)
                (not Atom)
               )
        )

        (Atom Bool 
               (
                (held x)
               )
        )
     
    )
)

(constraint (=> (and (= (locked Epoch!val!3 Node!val!0) false)
         (= (locked Epoch!val!4 Node!val!0) false)
         (= (locked Epoch!val!2 Node!val!0) false)
         (= (locked Epoch!val!1 Node!val!0) false)
         (= (locked Epoch!val!0 Node!val!0) false)
         (= (ep Node!val!0) Epoch!val!2)
         (= (held Node!val!0) true)
         (= (transfer Epoch!val!3 Node!val!0) false)
         (= (transfer Epoch!val!4 Node!val!0) false)
         (= (transfer Epoch!val!2 Node!val!0) true)
         (= (transfer Epoch!val!1 Node!val!0) false)
         (= (transfer Epoch!val!0 Node!val!0) false))
    (not (and (inv Node!val!0)))))

(check-synth)
